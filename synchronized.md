### 1.在 java 中守护线程和本地线程区别？
- java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。
- 两者的区别：唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。
- 扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。
### 2.线程与进程的区别？
- 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。
### 3.什么是多线程中的上下文切换？
- 多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。在上下文切换过程中，CPU 会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB 还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到 CPU 的内存中，直到他们被再次使用。上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。
### 4.死锁与活锁的区别，死锁与饥饿的区别？
- 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
- 产生死锁的必要条件：
1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
- 活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
- 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
- 饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
- Java 中导致饥饿的原因：
1. 高优先级线程吞噬所有的低优先级线程的 CPU 时间。
2. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
3. 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。
- Java 中用到的线程调度算法是什么？采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。
### 6.什么是线程组，为什么在 Java 中不推荐使用？
- ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。
### 7.为什么使用 Executor 框架？
- 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。
### 8.在 Java 中 Executor 和 Executors 的区别？
1. Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。
2. Executor 接口对象能执行我们的线程任务。
3. ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。
4. 使用 ThreadPoolExecutor 可以创建自定义线程池。
5. Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。
### 9.如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？
### 10.什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？
- 原子操作（atomic operation）意为”不可被中断的一个或一系列操作”。处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare & Set，或是 Compare & Swap，现在几乎所有的 CPU 指令都支持 CAS的原子操作。原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解.
- 原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
- 原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
- 原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater
- 解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）
### 11.Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？
- Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：
1. 可以使锁更公平
2. 可以使线程在等待锁的时候响应中断
3. 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
4. 可以在不同的范围，以不同的顺序获取和释放锁
- 整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。
### 12.什么是 Executors 框架？
- Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。
### 13.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？
- 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。
- JDK7 提供了 7 个阻塞队列。分别是：
1. ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
2. LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
3. PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
4. DelayQueue：一个使用优先级队列实现的无界阻塞队列。
5. SynchronousQueue：一个不存储元素的阻塞队列。
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
- Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。
- BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。
- 阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。
### 14.什么是 Callable 和 Future?
- Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的 Runnable。
- Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable用于产生结果，Future 用于获取结果。
### 15.什么是 FutureTask?使用 ExecutorService 启动任务。
- 在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable接口所以它可以提交给 Executor 来执行。
### 16.什么是并发容器的实现？
- 何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。
- 并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。
### 17.多线程同步和互斥有几种实现方法，都是什么？
- 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。
- 线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。
### 18.什么是竞争条件？你怎样发现和解决竞争？
- 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。
- 解决“ 检查和交流 ”竞争条件的一个简单方法是同步关键字并强制执行锁定，这将使此操作成为原子并确保块或方法仅由一个线程执行，并且操作结果将对所有线程都可见已完成的同步块或从同步块中退出线程。 
### 19.你将如何使用 thread dump？你将如何分析 Thread dump？
- 新建状态（New）:用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区中被分配了内存。
- 就绪状态（Runnable）:当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态，Java 虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得 CPU 的使用权。
- 运行状态（Running）:处于这个状态的线程占用 CPU，执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。
- 阻塞状态（Blocked）:阻塞状态是指线程因为某些原因放弃 CPU，暂时停止运行。当线程处于阻塞状态时，Java 虚拟机不会给线程分配 CPU。直到线程重新进入就绪状态，它才有机会转到运行状态。阻塞状态可分为以下 3 种：
1. 位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：当线程处于运行状态时，如果执行了某个对象的 wait()方法，Java 虚拟机就会把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。
2. 位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java 虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。
3. 其他阻塞状态（Otherwise Blocked）：当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I/O请求时，就会进入这个状态。
- 死亡状态（Dead）:当线程退出 run()方法时，就进入死亡状态，该线程结束生命周期。
### 20.为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？
- 当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。
### 21.Java 中你怎样唤醒一个阻塞的线程？
- 在 Java 发展史上曾经使用 suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait()和 notify()方法实现线程阻塞。首先 ，wait、notify 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行；其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。
### 22.在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？
- CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。
- Java 的 concurrent 包里面的 CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 await()方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 countDown()方法，这个调用 await()方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。
- CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。
### 23.什么是不可变对象，它对写并发应用有什么帮助？
- 不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。
1. 不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。
2. 不可变对象永远是线程安全的。
- 只有满足如下状态，一个对象才是不可变的:它的状态不能在创建后再被修改；所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。
### 24.Java 中用到的线程调度算法是什么？
- 计算机通常只有一个 CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU 的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得 CPU 的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待 CPU,JAVA 虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配 CPU 的使用权.有两种调度模型：分时调度模型和抢占式调度模型。
1. 分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。
2. Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。
### 25.什么是线程组，为什么在 Java 中不推荐使用？
- 线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。
### 26.为什么使用 Executor 框架比使用应用创建和管理线程好
- 为什么要使用 Executor 线程池框架
1. 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。
2. 调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。
3. 直接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。
- 使用 Executor 线程池框架的优点
1. 能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。
2. 可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。
3. 框架中已经有定时、定期、单线程、并发数控制等功能。
- 综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。
### 27.如何停止一个正在运行的线程？
- 在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。
- 使用 interrupt 方法终止线程，如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者 Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了 DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为 true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这里我们给出的建议是，不要使用 stop()方法，而是使用 Thread 提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。
### 28.notify()和 notifyAll()有什么区别？
- 当一个线程进入 wait 之后，就必须等其他线程 notify/notifyall,使用 notifyall,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。如果没把握，建议 notifyAll，防止 notigy 因为信号丢失而造成程序异常。
### 29.什么是 Daemon 线程？它有什么意义？
- 所谓后台(daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行 finally子句的情况下就会终止其 run()方法。比如：JVM 的垃圾回收线程就是 Daemon 线程，Finalizer 也是守护线程。
### 30.java 如何实现多线程之间的通讯和协作？
- 中断和共享变量
### 31.什么是可重入锁（ReentrantLock）？
```
举例来说明锁的可重入性
public class UnReentrant{
        Lock lock = new Lock();
        public void outer(){
                lock.lock();
                inner();
                lock.unlock();
        }
        public void inner(){
                lock.lock();
                //do something
                lock.unlock();
        }
}
```
- outer 中调用了 inner，outer 先锁住了 lock，这样 inner 就不能再获取 lock。其实调用 outer 的线程已经获取了 lock 锁，但是不能在 inner 中重复利用已经获取的锁资源，这种锁即称之为 不可重入可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。synchronized、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。
### 32.当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法
- 如果其他方法没有 synchronized 的话，其他线程是可以进入的。所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。
### 33.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？
- 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。
- 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。
- 乐观锁的实现方式：
1. 使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。
2. java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。
CAS 缺点：
1. ABA 问题：比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。
2. 循环时间长开销大：对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。
3. 只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。
### 34.SynchronizedMap 和 ConcurrentHashMap 有什么区别？
- SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。
ConcurrentHashMap 使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。
### 35.CopyOnWriteArrayList 可以用于什么应用场景？
- CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。
1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc；
2. 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；
- CopyOnWriteArrayList 透露的思想
1. 读写分离，读和写分开
2. 最终一致性
3. 使用另外开辟空间的思路，来解决并发冲突
### 36.什么叫线程安全？servlet 是线程安全吗?
- 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
- Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。
- Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。
- SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。
- Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。
### 37.volatile 有什么用？能否用一句话说明下 volatile 的应用场景？
- volatile 保证内存可见性和禁止指令重排。volatile 用于多线程环境下的单次操作(单次读或者单次写)。
- volatile关键字可以实现线程间的可见性，之所以可以实现这一点，原因在于JVM会保证被volatile修饰的变量，在线程栈中被线程使用时都会主动从共享内存(堆内存/主内存)中以实时的方式同步一次；另一方面，如果线程在工作内存中修改了volatile修饰的变量，也会被JVM要求立马刷新到共享内存中去。因此，即便某个线程修改了该变量，其他线程也可以立马感知到变化从而实现可见性
- 初识volatile
1. “为什么volatile关键字只能修饰类变量和实例变量呢？”关于问题，我们可以先进行思考，然后在文章的结尾集中探讨答案。机器硬件CPU&JAVA内存模型在深入理解volatile关键字之前，让我们先来回顾下并发问题产生的根本原因，这一点对于我们理解volatile关键字的存在意义是一个基础性问题。我们知道在计算机系统中所有的运算操作都是由CPU来完成的，而CPU运算需要从内存中加载数据，计算完后再将结果同步回内存，但是由于现代计算机的CPU的处理速度要比内存的访问速度牛逼N倍，如果CPU在进行数据运算时直接访问内存的话，由于内存的访问速度慢，这样就会拖慢CPU的运算效率。为了解决这一问题，伟大的计算机科学家们就想到了一个办法，通过在CPU和内存之间架设一层缓存，CPU不直接访问物理内存，而是将需要运算的数据从主内存中拷贝一份到缓存，运算的结果也通过缓存同步给主内存。通过这种方法CPU的运行速度就大大提高了，目前主流的CPU都有L1、L2、L3三级缓存。但是，这样的方式也带来了新的问题，那就是在多线程情况下同一份主内存中的数据值，会被拷贝多个副本放入CPU的缓存中，如果两个线程同时对一个变量值进行赋值操作的话，就会产生数据不一致的问题，例如：”变量i的初始值为0，两个线程同时加载到CPU缓存后，同时执行i+1的操作，按照道理说i的值此时应该是变成2，而实际情况主内存的值可能还是1，因为两个线程彼此是不知道对方已经改动了这个变量的值的“。而为了解决这样一个问题，一些CPU制造商如Intel开发了诸如MESI协议这样的缓存一致性控制协议来解决CPU缓存与主内存之间的数据不一致问题，其基本操作大概就是在某个线程通过CPU缓存写入主内存时，会通过信号的方式通知其他线程中CPU缓存中的值变为失效，从而让其他线程再次从主内存中同步一份数据到CPU缓存中。以上关于CPU缓存与内存的介绍，并不是为了探讨关于CPU的原理，而是为了说明并发数据不一致问题产生的基本缘由是什么！同理，JAVA内存模型中的定义中，也进行了类似的设计。在JAVA内存模型中，线程与主内存的关系是，线程并不直接操作主内存，而是通过将主内存中的变量拷贝到自己的工作内存中进行计算，完成后再将变量的值同步回主内存这样的方式进行工作。
2. JAVA内存模型定义了线程与主内存之间的抽象关系，如下：共享变量（类变量以及对象的全局实例变量等都是共享变量）存储于主内存中，每个线程都可以访问，这里的主内存可以看成是堆内存。每个线程都有私有的工作内存，这里的工作内存可以看成是栈内存。工作内存只存储该线程对共享变量的副本。线程不能直接操作主内存，只有先操作了工作内存之后才能通过工作内存写入主内存。以上关于工作内存及Java内存模型的概述，只是便于我们去理解JVM内存管理机制的一个抽象的概念，物理上并不是具体的存在。从具体情况上来讲因为Java程序是运行在JVM之上的，并没有直接调用到操作系统的底层接口去操作硬件，所以线程操作数据进行运算最终还是通过JVM调用了受操作系统管理的CPU资源去进行计算。而计算中涉及的CPU缓存与主内存的缓存一致性问题，则是操作系统层面的一层抽象，与Java工作内存彧主内存的划分并没有直接关系，它们是不同层次的设计。volatile关键字说到底是Java中对多线程并发问题提供语法机制之一，而要正确地理解Java多线程问题，要求我们必须深刻的理解“原子性”、“有序性”、“可见性”这三个非常重要和关键的特性。
3. 原子性:所谓原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到执行，要么所有的操作都不执行。这个原子性与数据库事务的原子性特性是一致的。Java内存模型只保证了基本的读取和赋值的原子性操作，其他操作均不保证。简单操作如："x=10",这个操作就是原子性的。因为从操作上看执行线程会将x=10这个动作写入工作内存，然后再将其写入主内存；即便在该线程进行数值刷新的过程中，也有其他线程对其进行刷新操作（如x=11）的情况x的最终结果也没有什么不一致的问题，因为最后要么是10，要么是11，两个线程谁先刷新都无所谓，那么在这种情况下我们就说这个操作是原子性的。其他操作如："x++"，这个操作就是非原子性的。为啥呢？我们来分析下x++这个动作都经过了哪些步骤：![Aaron Swartz](https://github.com/TigrexR/Interview/blob/master/image/synchronized-1.png) 此时y的正确值应该是6，但是线程A最终将y=2同步给了主内存，从而导致主内存中y的值变成了一个脏数据，从而产生了线程安全问题，所以我们说y++的操作不具备原子性，因为它分了三个步骤来执行一个操作。从上面的例子可以看到原子性是一个排他性的特性，如果需要保证y++具备原子性就需要确保y++动作的三个步骤完成前，不允许其他线程对y变量进行操作。因为Java的内存模型并不确保此类操作的原子性，所以有时候写Java代码时会让人感到代码中处处都充斥着线程不安全的操作，只是现在觉得多数程序员都在从事业务开发，面向的都是数据库编程，加上工程上都是集成了现成的开发框架，所以对于这一点感受并不是特别深刻，只有在少数场景下手动实现多线程编程时才会通过synchronized关键字进行加锁同步操作。然而，这个特性与volatile关键字有什么关系呢？事实上volatile关键字并不保证被修饰的类变量和实例变量具有原子性。这是因为被volatile关键字修饰的变量并不具备排他性，关于这一点，我们在下面说完另外两个特性后再分析下原因。
4. 可见性是指，当一个线程对共享变量进行了修改，那么其他线程可以立刻看到修改后的最新值。在Java多线程环境下，线程首次读取要操作的变量时，是先到主内存中获取该变量，然后将其放入工作内存，以后关于该变量的操作都是在以工作内存中的变量值为基准的。之后如果要修改该变量的值，也是直接修改工作内存中的变量，最后会在某一时刻将工作内存中该变量的值刷新同步回主内存，之后其他线程就能感知到该变量的变化，实现可见性了！只是什么时候将工作内存中的值同步会主内存，这个时间点在自然情况下是不确定的，所以假设线程A修改了变量的值之后，在正式将其同步会主内存之前，线程B获取了主内存中变量的原先值，而过了一会后线程A刷新了主内存，但是此时主内存中的变量值与线程B工作内存中的变量值已经不一致了，这个时候就出现不可见的问题了！在Java中本文的主角volatile关键字就可以解决变量在线程间不可见的问题。当一个变量被volatile关键字修饰之后，对于共享资源的操作会时刻保持与主内存的数据一致。因为被volatile关键字修饰的变量，如果某个线程对其进行了更改，它就会立马进行一次工作内存刷新同步至主内存的操作；同理，如果某个线程读取volatile关键字修饰的变量，那么该线程返回自己工作内存中的变量时，每次都会被要求从主内存再同步一次到工作内存中。除此之外synchronized关键字以及JUC包中提供的显示锁Lock也可以保证可见性。原因在于它们可以保证在同一时刻只有一个线程获得锁可以操作共享变量，完成工作内存中的运算在释放锁之前会确保工作内存中变更的变量新值会被刷新到主内存中。我们再回过头来分析下volatile关键字修饰的变量为什么在保证可见性以后还是不能确保原子性，实现完全的线程安全呢？我们还是以y++举例，这次变量y被volatile修饰了，有什么变化呢？假设第1步线程A从主内存拷贝了y的副本到工作内存后，此时线程B直接操作了y＝5这个动作，那么此时线程A中的副本y的值为1就不对了，因为被volatile修饰了，所以在第2步线程A使用y进行运算时，会再次从主内存中同步一次y的副本（y＝5），然后线程A执行y=y+1后，会立马执行第3步把y的值6立马同步刷新会主内存。初一看感觉volatile的关键字好像解决了y++这个操作的原子性问题，但实际上我们再看看，如果此时线程A已经执行完第2步了，此时线程B更改了变量y的值，虽然此时线程A知道变量y发生了变化，但是由于操作已经执行完，所以还是只能执行第3步把变量y的值覆盖回主内存，从而又造成了错误数据。所以从这个例子分析，volatile只是解决了y++第1步和第2步的原子性，并没有解决3个步骤的原子性，所以我们说volatile关键字并不能保证解决原子性问题，就是这个道理！
5. 有序性是指程序代码在执行的过程中要确保有数据依赖关系的代码要有先后顺序。由于代码编译存在指令重排的问题，所以程序编写的顺序与最后实际执行的指令可能先后顺序时错乱的，如果代码编写的先后顺序存在数据依赖关系，那么就有可能导致依赖于某条代码指令在它所依赖的代码指令执行之前就被执行了，从而导致程序出现错误的情况。在Java中的有序性就是要通过对指令重排的干预，避免掉因为指令重排导致的这种程序错误问题。volatile关键字就可以通过增加内存屏障的方式禁止指令重排，从而实现程序执行的有序性。除此之外的synchronized关键字以及JUC包中提供的显示锁Lock也可以保证有序性，因为同步所以与单线程的情况一样自然能够保证有序性。此外，Java内存模型本身也会通过一些happens-before原则的推导来确保在进行指令重排时程序代码执行的有序性。这里的happens-before原则有：程序次序规则、锁定规则、volatile变量规则、传递规则、线程启动规则、线程中断规则、线程终结规则、对象的终结规则等。
6. volatile实现机制通过上面内容的阅读，详细你对volatile关键字已经有了一定深入的了解了，下面我们再深入分析下volatile的实现机制。通过对OpenJDK中的unsafe.cpp源码的分析，会发现被volatile关键字修饰的变量会存在一个“lock:”的前缀。这个实际上相当于是一个内存屏障，该内存屏障会为指令的执行提供如下保障：确保指令重排序时不会将其后面的代码排到内存屏障之前。同样也会确保重排序是不会将其前面的代码排到内存屏障之后。确保在执行到内存屏障修饰的指令时前面的代码全部执行完成。强制将线程的工作内存中值的修改刷新至主内存中。
### 38.为什么代码会重排序？
- 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：在单线程环境下不能改变程序运行的结果；存在数据依赖关系的不允许重排序
- 需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。






## 进程和线程

### 1.线程和进程的概念、并行和并发的概念
1. 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

2. 线程，有时被称为轻量级进程（Lightweight Process,LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立、可调度的执行单元，是系统独立调度和分派CPU的基本单位，也指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。

3. 并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干端，使多个进程快速交替的执行。 

4. 并行（parallellism）:指在同一时刻，有多条指令在多个处理器上同时执行 

5. 通过多线程实现并发，并行： 
- java中的Thread类定义了多线程，通过多线程可以实现并发或并行。 
- 在CPU比较繁忙，资源不足的时候（开启了很多进程），操作系统只为一个含有多线程的进程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。 
- 在CPU资源比较充足的时候，一个进程内的多线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。 
- 至于多线程实现的是并发还是并行？上面所说，所写多线程可能被分配到一个CPU内核中执行，也可能被分配到不同CPU执行，分配过程是操作系统所为，不可人为控制。所以，如果有人问我我所写的多线程是并发还是并行的？我会说，都有可能。 
- 不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源

### 2创建线程的方式及实现
Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。 
1. 继承Thread类创建线程类 
- 重写run方法。该run（）方法的方法体就代表了线程需要完成的任务。 
- 创建Thread子类的实例。 
- 调用线程对象的start（）方法来启动该线程。

        public class TestCode1 extends Thread
        {
                private int i;
                public void run()
                {
                        for(;i<100;i++)
                        {
                        System.out.println(getName()+" "+i);
                        }
                }


                public static void main(String[] args) 
                {
                        for(int i=0;i<100;i++)
                        {
                        System.out.println(Thread.currentThread().getName()+" "+i);
                        if(i==20){
                                new TestCode1().start();
                                new TestCode1().start();
                        }
                        }
                }
        }

2. 实现Runnable接口创建线程类 
- 定义Runnable的实现类，重写run（）方法。 
- 创建Runnable实现类的实例，并以此作为Thread的target来创建对象，该对象才是真正的线程对象。

        public class TestCode2 implements Runnable
                {
                private int i;
                public void run()
                {
                        for(;i<100;i++)
                        {
                        System.out.println(Thread.currentThread().getName()+" "+i);
                        }
                }


                public static void main(String[] args) 
                {
                        for(int i=0;i<100;i++)
                        {
                        System.out.println(Thread.currentThread().getName()+" "+i);
                        if(i==20){
                                TestCode2 test=new TestCode2();
                                new Thread(test,"新线程1").start();
                                new Thread(test,"新线程2").start();
                        }
                        }
                }
        }

3. 使用Callable和Future创建线程 
- 创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。 
- 使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。 
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。 
- 调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。

        public class TestCode3 {
                public static void main(String[] args) {
                        TestCode3 test = new TestCode3();
                        FutureTask<Integer> task = new FutureTask<Integer>((Callable<Integer>)()->{
                        int i=0;
                        for(;i<100;i++){
                                System.out.println(Thread.currentThread().getName()+"循环变量i的值："+i);
                        }
                        return i;
                        });
                        for(int i=0;i<100;i++){
                        System.out.println(Thread.currentThread().getName()+"循环变量i的值："+i);
                        if(i==20){
                                new Thread(task,"有返回值的线程").start();
                        }
                        try{
                                System.out.println("子线程的返回值："+task.get());
                        }
                        catch (Exception e) {
                                e.printStackTrace();
                        }
                        }
                }
        }

4. 浅谈三种方式优劣势 
通过继承Thread类或实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。 
1.采用实现Runnable、Callable接口的方式创建多线程的优缺点： 
优势：（1）线程类只是实现了Runnable接口与Callable接口，还可以继承其他类。 
（2）在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 
劣势：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。 
2.采用继承Thread类的方法创建多线程的优缺点： 
劣势：因为线程类已经继承了Thread类，所以不能再继承其他父类。 
优势：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。 
5. 总结 
鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

### 3.synchronized 实现原理（对象监视器）
1. Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。
- 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。
https://blog.csdn.net/javazejian/article/details/72828483

### 38.说说 CountDownLatch、CyclicBarrier 原理和区别
https://blog.csdn.net/tolcf/article/details/50925145
- 可以观看 https://github.com/TigrexR/JavaBase 中的CyclicBarrierTesth和CountDownTest类\

进程间通信的方式

说说 CountDownLatch、CyclicBarrier 原理和区别

说说 Semaphore 原理

说说 Exchanger 原理

ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理

讲讲线程池的实现原理

线程池的几种实现方式

线程的生命周期，状态是如何转移的

可参考：《Java多线程编程核心技术》
## 锁机制

### 1.说说线程安全问题，什么是线程安全，如何保证线程安全
1. 

重入锁的概念，重入锁为什么可以防止死锁

产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）

如何检查死锁（通过jConsole检查死锁）

synchronized 与 lock 的区别

AQS同步队列

CAS无锁的概念、乐观锁和悲观锁

常见的原子操作类

什么是ABA问题，出现ABA问题JDK是如何解决的

乐观锁的业务场景及实现方式

Java 8并法包下常见的并发类

偏向锁、轻量级锁、重量级锁、自旋锁的概念

可参考：《Java多线程编程核心技术》