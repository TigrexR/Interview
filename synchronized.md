### 1.在 java 中守护线程和本地线程区别？
- java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。任何线程都可以设置为守护线程和用户线程，通过方法 Thread.setDaemon(boolon)；true 则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在 Thread.start()之前调用，否则运行时会抛出异常。
- 两者的区别：唯一的区别是判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程；比如 JVM 的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java 虚拟机上仅剩的线程时，Java 虚拟机会自动离开。
- 扩展：Thread Dump 打印出来的线程信息，含有 daemon 字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows 下的监听 Ctrl+break的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。
### 2.线程与进程的区别？
- 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。
### 3.什么是多线程中的上下文切换？
- 多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。
### 4.死锁与活锁的区别，死锁与饥饿的区别？
- 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
- 产生死锁的必要条件：
1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
- 活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。
- 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。
- 饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
- Java 中导致饥饿的原因：
1. 高优先级线程吞噬所有的低优先级线程的 CPU 时间。
2. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
3. 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。
- Java 中用到的线程调度算法是什么？采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。
### 6.什么是线程组，为什么在 Java 中不推荐使用？
- ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。为什么不推荐使用？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。
### 7.为什么使用 Executor 框架？
- 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。接使用 new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。
### 8.在 Java 中 Executor 和 Executors 的区别？
1. Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。
2. Executor 接口对象能执行我们的线程任务。
3. ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。
4. 使用 ThreadPoolExecutor 可以创建自定义线程池。
5. Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。
### 9.如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？
### 10.什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？
- 原子操作（atomic operation）意为”不可被中断的一个或一系列操作”。处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare & Set，或是 Compare & Swap，现在几乎所有的 CPU 指令都支持 CAS的原子操作。原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解.
- 原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference
- 原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
- 原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater
- 解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）
### 11.Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？
- Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：
1. 可以使锁更公平
2. 可以使线程在等待锁的时候响应中断
3. 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间
4. 可以在不同的范围，以不同的顺序获取和释放锁
- 整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。
### 12.什么是 Executors 框架？
- Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。
### 13.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？
- 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。
- JDK7 提供了 7 个阻塞队列。分别是：
1. ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
2. LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
3. PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
4. DelayQueue：一个使用优先级队列实现的无界阻塞队列。
5. SynchronousQueue：一个不存储元素的阻塞队列。
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
- Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。
- BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。
- 阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。
### 14.什么是 Callable 和 Future?
- Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的 Runnable。
- Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable用于产生结果，Future 用于获取结果。
### 15.什么是 FutureTask?使用 ExecutorService 启动任务。
- 在 Java 并发程序中 FutureTask 表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是调用了 Runnable接口所以它可以提交给 Executor 来执行。
### 16.什么是并发容器的实现？
- 何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。
- 并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。
### 17.多线程同步和互斥有几种实现方法，都是什么？
- 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。
- 线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。
### 18.什么是竞争条件？你怎样发现和解决竞争？
- 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。


## 进程和线程

### 1.线程和进程的概念、并行和并发的概念
1. 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

2. 线程，有时被称为轻量级进程（Lightweight Process,LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立、可调度的执行单元，是系统独立调度和分派CPU的基本单位，也指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。

3. 并发（concurrency）：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干端，使多个进程快速交替的执行。 

4. 并行（parallellism）:指在同一时刻，有多条指令在多个处理器上同时执行 

5. 通过多线程实现并发，并行： 
- java中的Thread类定义了多线程，通过多线程可以实现并发或并行。 
- 在CPU比较繁忙，资源不足的时候（开启了很多进程），操作系统只为一个含有多线程的进程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。 
- 在CPU资源比较充足的时候，一个进程内的多线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。 
- 至于多线程实现的是并发还是并行？上面所说，所写多线程可能被分配到一个CPU内核中执行，也可能被分配到不同CPU执行，分配过程是操作系统所为，不可人为控制。所以，如果有人问我我所写的多线程是并发还是并行的？我会说，都有可能。 
- 不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源

### 2创建线程的方式及实现
Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。 
1. 继承Thread类创建线程类 
- 重写run方法。该run（）方法的方法体就代表了线程需要完成的任务。 
- 创建Thread子类的实例。 
- 调用线程对象的start（）方法来启动该线程。

        public class TestCode1 extends Thread
        {
                private int i;
                public void run()
                {
                        for(;i<100;i++)
                        {
                        System.out.println(getName()+" "+i);
                        }
                }


                public static void main(String[] args) 
                {
                        for(int i=0;i<100;i++)
                        {
                        System.out.println(Thread.currentThread().getName()+" "+i);
                        if(i==20){
                                new TestCode1().start();
                                new TestCode1().start();
                        }
                        }
                }
        }

2. 实现Runnable接口创建线程类 
- 定义Runnable的实现类，重写run（）方法。 
- 创建Runnable实现类的实例，并以此作为Thread的target来创建对象，该对象才是真正的线程对象。

        public class TestCode2 implements Runnable
                {
                private int i;
                public void run()
                {
                        for(;i<100;i++)
                        {
                        System.out.println(Thread.currentThread().getName()+" "+i);
                        }
                }


                public static void main(String[] args) 
                {
                        for(int i=0;i<100;i++)
                        {
                        System.out.println(Thread.currentThread().getName()+" "+i);
                        if(i==20){
                                TestCode2 test=new TestCode2();
                                new Thread(test,"新线程1").start();
                                new Thread(test,"新线程2").start();
                        }
                        }
                }
        }

3. 使用Callable和Future创建线程 
- 创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。 
- 使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。 
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。 
- 调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。

        public class TestCode3 {
                public static void main(String[] args) {
                        TestCode3 test = new TestCode3();
                        FutureTask<Integer> task = new FutureTask<Integer>((Callable<Integer>)()->{
                        int i=0;
                        for(;i<100;i++){
                                System.out.println(Thread.currentThread().getName()+"循环变量i的值："+i);
                        }
                        return i;
                        });
                        for(int i=0;i<100;i++){
                        System.out.println(Thread.currentThread().getName()+"循环变量i的值："+i);
                        if(i==20){
                                new Thread(task,"有返回值的线程").start();
                        }
                        try{
                                System.out.println("子线程的返回值："+task.get());
                        }
                        catch (Exception e) {
                                e.printStackTrace();
                        }
                        }
                }
        }

4. 浅谈三种方式优劣势 
通过继承Thread类或实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。 
1.采用实现Runnable、Callable接口的方式创建多线程的优缺点： 
优势：（1）线程类只是实现了Runnable接口与Callable接口，还可以继承其他类。 
（2）在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 
劣势：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。 
2.采用继承Thread类的方法创建多线程的优缺点： 
劣势：因为线程类已经继承了Thread类，所以不能再继承其他父类。 
优势：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。 
5. 总结 
鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

### 3.synchronized 实现原理（对象监视器）
1. Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。
- 在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。
https://blog.csdn.net/javazejian/article/details/72828483

### 4.volatile 实现原理（禁止指令重排、刷新内存）
- volatile关键字可以实现线程间的可见性，之所以可以实现这一点，原因在于JVM会保证被volatile修饰的变量，在线程栈中被线程使用时都会主动从共享内存(堆内存/主内存)中以实时的方式同步一次；另一方面，如果线程在工作内存中修改了volatile修饰的变量，也会被JVM要求立马刷新到共享内存中去。因此，即便某个线程修改了该变量，其他线程也可以立马感知到变化从而实现可见性
- 初识volatile

1. “为什么volatile关键字只能修饰类变量和实例变量呢？”关于问题，我们可以先进行思考，然后在文章的结尾集中探讨答案。机器硬件CPU&JAVA内存模型
在深入理解volatile关键字之前，让我们先来回顾下并发问题产生的根本原因，这一点对于我们理解volatile关键字的存在意义是一个基础性问题。我们知道在计算机系统中所有的运算操作都是由CPU来完成的，而CPU运算需要从内存中加载数据，计算完后再将结果同步回内存，但是由于现代计算机的CPU的处理速度要比内存的访问速度牛逼N倍，如果CPU在进行数据运算时直接访问内存的话，由于内存的访问速度慢，这样就会拖慢CPU的运算效率。为了解决这一问题，伟大的计算机科学家们就想到了一个办法，通过在CPU和内存之间架设一层缓存，CPU不直接访问物理内存，而是将需要运算的数据从主内存中拷贝一份到缓存，运算的结果也通过缓存同步给主内存。通过这种方法CPU的运行速度就大大提高了，目前主流的CPU都有L1、L2、L3三级缓存。但是，这样的方式也带来了新的问题，那就是在多线程情况下同一份主内存中的数据值，会被拷贝多个副本放入CPU的缓存中，如果两个线程同时对一个变量值进行赋值操作的话，就会产生数据不一致的问题，例如：”变量i的初始值为0，两个线程同时加载到CPU缓存后，同时执行i+1的操作，按照道理说i的值此时应该是变成2，而实际情况主内存的值可能还是1，因为两个线程彼此是不知道对方已经改动了这个变量的值的“。而为了解决这样一个问题，一些CPU制造商如Intel开发了诸如MESI协议这样的缓存一致性控制协议来解决CPU缓存与主内存之间的数据不一致问题，其基本操作大概就是在某个线程通过CPU缓存写入主内存时，会通过信号的方式通知其他线程中CPU缓存中的值变为失效，从而让其他线程再次从主内存中同步一份数据到CPU缓存中。以上关于CPU缓存与内存的介绍，并不是为了探讨关于CPU的原理，而是为了说明并发数据不一致问题产生的基本缘由是什么！同理，JAVA内存模型中的定义中，也进行了类似的设计。在JAVA内存模型中，线程与主内存的关系是，线程并不直接操作主内存，而是通过将主内存中的变量拷贝到自己的工作内存中进行计算，完成后再将变量的值同步回主内存这样的方式进行工作。
2. JAVA内存模型定义了线程与主内存之间的抽象关系，如下：共享变量（类变量以及对象的全局实例变量等都是共享变量）存储于主内存中，每个线程都可以访问，这里的主内存可以看成是堆内存。每个线程都有私有的工作内存，这里的工作内存可以看成是栈内存。工作内存只存储该线程对共享变量的副本。线程不能直接操作主内存，只有先操作了工作内存之后才能通过工作内存写入主内存。以上关于工作内存及Java内存模型的概述，只是便于我们去理解JVM内存管理机制的一个抽象的概念，物理上并不是具体的存在。从具体情况上来讲因为Java程序是运行在JVM之上的，并没有直接调用到操作系统的底层接口去操作硬件，所以线程操作数据进行运算最终还是通过JVM调用了受操作系统管理的CPU资源去进行计算。而计算中涉及的CPU缓存与主内存的缓存一致性问题，则是操作系统层面的一层抽象，与Java工作内存彧主内存的划分并没有直接关系，它们是不同层次的设计。volatile关键字说到底是Java中对多线程并发问题提供语法机制之一，而要正确地理解Java多线程问题，要求我们必须深刻的理解“原子性”、“有序性”、“可见性”这三个非常重要和关键的特性。
3. 原子性:所谓原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到执行，要么所有的操作都不执行。这个原子性与数据库事务的原子性特性是一致的。Java内存模型只保证了基本的读取和赋值的原子性操作，其他操作均不保证。简单操作如："x=10",这个操作就是原子性的。因为从操作上看执行线程会将x=10这个动作写入工作内存，然后再将其写入主内存；即便在该线程进行数值刷新的过程中，也有其他线程对其进行刷新操作（如x=11）的情况x的最终结果也没有什么不一致的问题，因为最后要么是10，要么是11，两个线程谁先刷新都无所谓，那么在这种情况下我们就说这个操作是原子性的。其他操作如："x++"，这个操作就是非原子性的。为啥呢？我们来分析下x++这个动作都经过了哪些步骤：![Aaron Swartz](https://github.com/TigrexR/Interview/blob/master/image/synchronized-1.png) 此时y的正确值应该是6，但是线程A最终将y=2同步给了主内存，从而导致主内存中y的值变成了一个脏数据，从而产生了线程安全问题，所以我们说y++的操作不具备原子性，因为它分了三个步骤来执行一个操作。从上面的例子可以看到原子性是一个排他性的特性，如果需要保证y++具备原子性就需要确保y++动作的三个步骤完成前，不允许其他线程对y变量进行操作。因为Java的内存模型并不确保此类操作的原子性，所以有时候写Java代码时会让人感到代码中处处都充斥着线程不安全的操作，只是现在觉得多数程序员都在从事业务开发，面向的都是数据库编程，加上工程上都是集成了现成的开发框架，所以对于这一点感受并不是特别深刻，只有在少数场景下手动实现多线程编程时才会通过synchronized关键字进行加锁同步操作。然而，这个特性与volatile关键字有什么关系呢？事实上volatile关键字并不保证被修饰的类变量和实例变量具有原子性。这是因为被volatile关键字修饰的变量并不具备排他性，关于这一点，我们在下面说完另外两个特性后再分析下原因。
4. 可见性是指，当一个线程对共享变量进行了修改，那么其他线程可以立刻看到修改后的最新值。在Java多线程环境下，线程首次读取要操作的变量时，是先到主内存中获取该变量，然后将其放入工作内存，以后关于该变量的操作都是在以工作内存中的变量值为基准的。之后如果要修改该变量的值，也是直接修改工作内存中的变量，最后会在某一时刻将工作内存中该变量的值刷新同步回主内存，之后其他线程就能感知到该变量的变化，实现可见性了！只是什么时候将工作内存中的值同步会主内存，这个时间点在自然情况下是不确定的，所以假设线程A修改了变量的值之后，在正式将其同步会主内存之前，线程B获取了主内存中变量的原先值，而过了一会后线程A刷新了主内存，但是此时主内存中的变量值与线程B工作内存中的变量值已经不一致了，这个时候就出现不可见的问题了！在Java中本文的主角volatile关键字就可以解决变量在线程间不可见的问题。当一个变量被volatile关键字修饰之后，对于共享资源的操作会时刻保持与主内存的数据一致。因为被volatile关键字修饰的变量，如果某个线程对其进行了更改，它就会立马进行一次工作内存刷新同步至主内存的操作；同理，如果某个线程读取volatile关键字修饰的变量，那么该线程返回自己工作内存中的变量时，每次都会被要求从主内存再同步一次到工作内存中。除此之外synchronized关键字以及JUC包中提供的显示锁Lock也可以保证可见性。原因在于它们可以保证在同一时刻只有一个线程获得锁可以操作共享变量，完成工作内存中的运算在释放锁之前会确保工作内存中变更的变量新值会被刷新到主内存中。我们再回过头来分析下volatile关键字修饰的变量为什么在保证可见性以后还是不能确保原子性，实现完全的线程安全呢？我们还是以y++举例，这次变量y被volatile修饰了，有什么变化呢？假设第1步线程A从主内存拷贝了y的副本到工作内存后，此时线程B直接操作了y＝5这个动作，那么此时线程A中的副本y的值为1就不对了，因为被volatile修饰了，所以在第2步线程A使用y进行运算时，会再次从主内存中同步一次y的副本（y＝5），然后线程A执行y=y+1后，会立马执行第3步把y的值6立马同步刷新会主内存。初一看感觉volatile的关键字好像解决了y++这个操作的原子性问题，但实际上我们再看看，如果此时线程A已经执行完第2步了，此时线程B更改了变量y的值，虽然此时线程A知道变量y发生了变化，但是由于操作已经执行完，所以还是只能执行第3步把变量y的值覆盖回主内存，从而又造成了错误数据。所以从这个例子分析，volatile只是解决了y++第1步和第2步的原子性，并没有解决3个步骤的原子性，所以我们说volatile关键字并不能保证解决原子性问题，就是这个道理！
5. 有序性是指程序代码在执行的过程中要确保有数据依赖关系的代码要有先后顺序。由于代码编译存在指令重排的问题，所以程序编写的顺序与最后实际执行的指令可能先后顺序时错乱的，如果代码编写的先后顺序存在数据依赖关系，那么就有可能导致依赖于某条代码指令在它所依赖的代码指令执行之前就被执行了，从而导致程序出现错误的情况。在Java中的有序性就是要通过对指令重排的干预，避免掉因为指令重排导致的这种程序错误问题。volatile关键字就可以通过增加内存屏障的方式禁止指令重排，从而实现程序执行的有序性。除此之外的synchronized关键字以及JUC包中提供的显示锁Lock也可以保证有序性，因为同步所以与单线程的情况一样自然能够保证有序性。此外，Java内存模型本身也会通过一些happens-before原则的推导来确保在进行指令重排时程序代码执行的有序性。这里的happens-before原则有：程序次序规则、锁定规则、volatile变量规则、传递规则、线程启动规则、线程中断规则、线程终结规则、对象的终结规则等。
6. volatile实现机制通过上面内容的阅读，详细你对volatile关键字已经有了一定深入的了解了，下面我们再深入分析下volatile的实现机制。通过对OpenJDK中的unsafe.cpp源码的分析，会发现被volatile关键字修饰的变量会存在一个“lock:”的前缀。这个实际上相当于是一个内存屏障，该内存屏障会为指令的执行提供如下保障：确保指令重排序时不会将其后面的代码排到内存屏障之前。同样也会确保重排序是不会将其前面的代码排到内存屏障之后。确保在执行到内存屏障修饰的指令时前面的代码全部执行完成。强制将线程的工作内存中值的修改刷新至主内存中。

### 38.说说 CountDownLatch、CyclicBarrier 原理和区别
https://blog.csdn.net/tolcf/article/details/50925145
- 可以观看 https://github.com/TigrexR/JavaBase 中的CyclicBarrierTesth和CountDownTest类\

进程间通信的方式

说说 CountDownLatch、CyclicBarrier 原理和区别

说说 Semaphore 原理

说说 Exchanger 原理

ThreadLocal 原理分析，ThreadLocal为什么会出现OOM，出现的深层次原理

讲讲线程池的实现原理

线程池的几种实现方式

线程的生命周期，状态是如何转移的

可参考：《Java多线程编程核心技术》
## 锁机制

### 1.说说线程安全问题，什么是线程安全，如何保证线程安全
1. 

重入锁的概念，重入锁为什么可以防止死锁

产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）

如何检查死锁（通过jConsole检查死锁）

synchronized 与 lock 的区别

AQS同步队列

CAS无锁的概念、乐观锁和悲观锁

常见的原子操作类

什么是ABA问题，出现ABA问题JDK是如何解决的

乐观锁的业务场景及实现方式

Java 8并法包下常见的并发类

偏向锁、轻量级锁、重量级锁、自旋锁的概念

可参考：《Java多线程编程核心技术》